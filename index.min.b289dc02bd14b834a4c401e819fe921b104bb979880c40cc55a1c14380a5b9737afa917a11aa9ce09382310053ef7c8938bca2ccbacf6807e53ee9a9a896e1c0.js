var suggestions=document.getElementById("suggestions"),search=document.getElementById("search");search!==null&&document.addEventListener("keydown",inputFocus);function inputFocus(e){e.ctrlKey&&e.key==="/"&&(e.preventDefault(),search.focus()),e.key==="Escape"&&(search.blur(),suggestions.classList.add("d-none"))}document.addEventListener("click",function(e){var t=suggestions.contains(e.target);t||suggestions.classList.add("d-none")}),document.addEventListener("keydown",suggestionFocus);function suggestionFocus(e){const s=suggestions.classList.contains("d-none");if(s)return;const t=[...suggestions.querySelectorAll("a")];if(t.length===0)return;const n=t.indexOf(document.activeElement);if(e.key==="ArrowUp"){e.preventDefault();const s=n>0?n-1:0;t[s].focus()}else if(e.key==="ArrowDown"){e.preventDefault();const s=n+1<t.length?n+1:n;t[s].focus()}}(function(){var e=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:"id",store:["href","title","description"],index:["title","description","content"]}});e.add({id:0,href:"/docs/usage/environment-variables/",title:"Environment variables",description:"Working with environment variables.",content:`Overview #ðŸ‘‰ This section assumes you have already run 'make all' or 'make env' command from root project directory. Project has built-in support for environment variables. Freshly cloned project uses 3 of them.
GODOG_DEBUG=false GODOG_MY_APP_URL=http://localhost:1234 GODOG_JSON_SCHEMA_DIR=./assets/test_server/doc/schema which can be found in .env file.
Further usage #You can add/modify/remove any environment variables. In code, current environment variables are defined at top of main_test.go file
const ( //envDebug describes environment variable responsible for debug mode - (true/false). envDebug = \u0026quot;GODOG_DEBUG\u0026quot; // envMyAppURL describes URL to \u0026quot;My app\u0026quot; - should be valid URL. envMyAppURL = \u0026quot;GODOG_MY_APP_URL\u0026quot; // envJsonSchemaDir path to JSON schemas dir - relative path from this file's directory. envJsonSchemaDir = \u0026quot;GODOG_JSON_SCHEMA_DIR\u0026quot; ) and further used for example as pre-defined variables in every scenario like this (os.Getenv obtains environment variable from .env file or shell):
ctx.Before(func(ctx context.Context, sc *godog.Scenario) (context.Context, error) { scenario.APIContext.ResetState(isDebug) // Here you can define more scenario-scoped values using scenario.APIContext.Cache.Save() method scenario.APIContext.Cache.Save(\u0026quot;MY_APP_URL\u0026quot;, os.Getenv(envMyAppURL)) scenario.APIContext.Cache.Save(\u0026quot;CWD\u0026quot;, wd) // current working directory - full OS path to this file return ctx, nil }) Above example shows usage of Cache utility service, which is responsible for storing values across scenario.
`}),e.add({id:1,href:"/docs/steps-definitions/creating-custom-steps/",title:"Create your own steps",description:"How to create your own steps.",content:`This repository contains only skeleton with low-level steps for testing JSON/XML/YAML or HTML API. As you start testing your unique project, most likely you will create new steps matching your business logic.
To do so, first, you have to add it in defs/scenario.go and later, use it to map it with reg-exp - english sentence in main_test.go.
This setup supports you with adding new steps by exposing internal APIContext\u0026rsquo;s services.
As an example, let\u0026rsquo;s assume, before you can work with your API, you have to log-in user. Most likely, at first, you will write scenario like this:
Feature: Authentication Scenario: Successful login #--------------------------------------------------------------------------------- # Successful authentication Given I send \u0026quot;POST\u0026quot; request to \u0026quot;{{.MY_APP_URL}}/auth/login\u0026quot; with body and headers: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;{{.ADMIN_EMAIL}}\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;{{.ADMIN_PASSWORD}}\u0026quot; }, \u0026quot;headers\u0026quot;: {} } \u0026quot;\u0026quot;\u0026quot; Then the response status code should be 200 And the response body should have type \u0026quot;JSON\u0026quot; And the \u0026quot;JSON\u0026quot; response should have node \u0026quot;access_token\u0026quot; And I save from the last response \u0026quot;JSON\u0026quot; node \u0026quot;access_token\u0026quot; as \u0026quot;USER_TOKEN\u0026quot; Naturally, previously you added environment variables similar to GODOG_ADMIN_EMAIL and GODOG_ADMIN_PASSWORD into .env file and then injected it, into all scenario caches with following directives (main_test.go):
ctx.Before(func(ctx context.Context, sc *godog.Scenario) (context.Context, error) { scenario.APIContext.ResetState(isDebug) // Here you can define more scenario-scoped values using scenario.APIContext.Cache.Save() method scenario.APIContext.Cache.Save(\u0026quot;MY_APP_URL\u0026quot;, os.Getenv(envMyAppURL)) scenario.APIContext.Cache.Save(\u0026quot;CWD\u0026quot;, wd) // current working directory - full OS path to this file scenario.APIContext.Cache.Save(\u0026quot;ADMIN_EMAIL\u0026quot;, os.Getenv(\u0026quot;GODOG_ADMIN_EMAIL\u0026quot;)) scenario.APIContext.Cache.Save(\u0026quot;ADMIN_PASSWORD\u0026quot;, os.Getenv(\u0026quot;GODOG_ADMIN_PASSWORD\u0026quot;)) return ctx, nil }) Quickly, you realize, that each scenario need to contain above steps. You try to figure out, how to minimize amount of steps required in each scenario and you come up with idea of writing equivalent higher-level step:
Given I log in user with email \u0026quot;{{.ADMIN_EMAIL}}\u0026quot; and password \u0026quot;{{.ADMIN_PASSWORD}}\u0026quot; and save its access token in scenario cache as \u0026quot;ADMIN_ACCESS_TOKEN\u0026quot; First, what you should do, is to write placeholder method in scenario.go:
func (s *Scenario) ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs(emailTemplate, passwordTemplate, cacheKey string) error { return godog.ErrPending } Then, you should map this func to sentence in main_test.go:
ctx.Step(\`^I log in user with email \u0026quot;([^\u0026quot;]*)\u0026quot; and password \u0026quot;([^\u0026quot;]*)\u0026quot; and save its access token in scenario cache as \u0026quot;([^\u0026quot;]*)\u0026quot;\$\`, scenario.ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs) At this moment, you have pending step. Now, you need to fulfill method\u0026rsquo;s body.
First what you want to do is to use APIContext.TemplateEngine service to obtain data from template values of first and second step argument. You may want to pass fixed email and password, but also you may want to generate data, register user with it and then pass template values of new user or obtain them from .env file like you did above. For example:
Given I log in user with email \u0026quot;admin@gmail.com\u0026quot; and password \u0026quot;admin123\u0026quot; and ... Given I log in user with email \u0026quot;{{.RANDOM_EMAIL}}\u0026quot; and password \u0026quot;{{.RANDOM_PASSWORD}}\u0026quot; and ... Given I log in user with email \u0026quot;{{.ADMIN_EMAIL}}\u0026quot; and password \u0026quot;{{.ADMIN_PASSWORD}}\u0026quot; and ... So you have to add following code to make it happen:
func (s *Scenario) ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs(emailTemplate, passwordTemplate, cacheKey string) error { email, err := s.APIContext.TemplateEngine.Replace(emailTemplate, s.APIContext.Cache.All()) if err != nil { return err } password, err := s.APIContext.TemplateEngine.Replace(passwordTemplate, s.APIContext.Cache.All()) if err != nil { return err } } Next, you need to send HTTP(s) request. To do so, you use already written method (ISendRequestToWithBodyAndHeaders):
func (s *Scenario) ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs(emailTemplate, passwordTemplate, cacheKey string) error { email, err := s.APIContext.TemplateEngine.Replace(emailTemplate, s.APIContext.Cache.All()) if err != nil { return err } password, err := s.APIContext.TemplateEngine.Replace(passwordTemplate, s.APIContext.Cache.All()) if err != nil { return err } docString := godog.DocString{Content: fmt.Sprintf(\`{ \u0026quot;body\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;%s\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;%s\u0026quot; }, headers: {} }\`, email, password)} if err = s.ISendRequestToWithBodyAndHeaders(http.MethodPost, \u0026quot;{{.MY_APP_URL}}/auth/login\u0026quot;, \u0026amp;docString); err != nil { return err } } After that, you want to make few assertions:
func (s *Scenario) ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs(emailTemplate, passwordTemplate, cacheKey string) error { email, err := s.APIContext.TemplateEngine.Replace(emailTemplate, s.APIContext.Cache.All()) if err != nil { return err } password, err := s.APIContext.TemplateEngine.Replace(passwordTemplate, s.APIContext.Cache.All()) if err != nil { return err } docString := godog.DocString{Content: fmt.Sprintf(\`{ \u0026quot;body\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;%s\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;%s\u0026quot; }, headers: {} }\`, email, password)} if err = s.ISendRequestToWithBodyAndHeaders(http.MethodPost, \u0026quot;{{.MY_APP_URL}}/auth/login\u0026quot;, \u0026amp;docString); err != nil { return err } if err = s.TheResponseStatusCodeShouldBe(200); err != nil { return err } if err = s.TheResponseBodyShouldHaveType(\u0026quot;JSON\u0026quot;); err != nil { return err } if err = s.TheResponseShouldHaveNode(\u0026quot;JSON\u0026quot;, \u0026quot;access_token\u0026quot;); err != nil { return err } } Now, you only need to save access_token node and add short step documentation, to help others and future yourself work with that step:
// ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs logs in user in my app and save it's access token in provided cacheKey // internally method relies upon MY_APP_URL cache key. func (s *Scenario) ILogInUserWithEmailAndPasswordAndSaveItsAccessTokenInScenarioCacheAs(emailTemplate, passwordTemplate, cacheKey string) error { email, err := s.APIContext.TemplateEngine.Replace(emailTemplate, s.APIContext.Cache.All()) if err != nil { return err } password, err := s.APIContext.TemplateEngine.Replace(passwordTemplate, s.APIContext.Cache.All()) if err != nil { return err } docString := godog.DocString{Content: fmt.Sprintf(\`{ \u0026quot;body\u0026quot;: { \u0026quot;email\u0026quot;: \u0026quot;%s\u0026quot;, \u0026quot;password\u0026quot;: \u0026quot;%s\u0026quot; }, headers: {} }\`, email, password)} if err = s.ISendRequestToWithBodyAndHeaders(http.MethodPost, \u0026quot;{{.MY_APP_URL}}/auth/login\u0026quot;, \u0026amp;docString); err != nil { return err } if err = s.TheResponseStatusCodeShouldBe(200); err != nil { return err } if err = s.TheResponseBodyShouldHaveType(\u0026quot;JSON\u0026quot;); err != nil { return err } if err = s.TheResponseShouldHaveNode(\u0026quot;JSON\u0026quot;, \u0026quot;access_token\u0026quot;); err != nil { return err } if err = s.ISaveFromTheLastResponseNodeAs(\u0026quot;JSON\u0026quot;, \u0026quot;access_token\u0026quot;, cacheKey); err != nil { return err } return nil } `}),e.add({id:2,href:"/docs/steps-definitions/data-generation/",title:"Data generation",description:"",content:""}),e.add({id:3,href:"/docs/prologue/",title:"Prologue",description:"Prologue Doks.",content:""}),e.add({id:4,href:"/docs/steps-definitions/http-requests/",title:"HTTP requests",description:"",content:""}),e.add({id:5,href:"/docs/usage/",title:"Usage",description:"",content:""}),e.add({id:6,href:"/docs/steps-definitions/flow-control/",title:"Flow control",description:"",content:""}),e.add({id:7,href:"/docs/steps-definitions/",title:"Steps definitions",description:"",content:""}),e.add({id:8,href:"/docs/usage/godog-cli/",title:"CLI: godog",description:"How to run tests using godog CLI.",content:`Description #Godog CLI is program that knows how to run tests written with gherkin/cucmber syntax. Under the hood it uses GoLang.
ðŸ‘‰ Godog CLI is depreciated method for running tests, see https://github.com/cucumber/godog/discussions/478 ðŸ‘‰ This section assumes you have already run 'make all' or 'make download-dependencies' command from root project directory and have globally visible godog binary in your shell. Usages #Project\u0026rsquo;s Makefile contains command that demonstrates usage of godog CLI to run tests:
make tests-using-host To run tests directly by godog CLI try:
godog run features/ This mode run all tests from features/ directory synchronously.
To run all tests from features/ asynchronously add --concurrency flag with desired value. General rule of thumb is that value should not be greater than number of CPUs on host machine. It is also beneficial to add --format=progress flag to change display of format to more convenient for asynchronous mode.
godog run features/ --format=progress --concurrency=2 Tests also can be run selectively simply by passing path to them
godog run features/path/to/your/test.feature If you mark few scenarios or features with any tag (for example: smoke), you can run them by
godog run --tags=smoke For more info see godog\u0026rsquo;s README CLI section.
`}),e.add({id:9,href:"/docs/steps-definitions/debugging/debug-mode/",title:"Activate/deactivate debug mode.",description:"Activate/deactivate debug mode.",content:`I start debug mode #This step temporarily turns on debugging mode inside scenario. You can think of it as setting environment variable GODOG_DEBUG to true for a while.
Example:
Given I start debug mode I stop debug mode #This step turns off debugging mode in given scenario.
Example:
Given I stop debug mode `}),e.add({id:10,href:"/docs/steps-definitions/assertions/response-body/",title:"HTTP response body",description:"HTTP response body.",content:`the response body should (not )?have format \u0026ldquo;(JSON|YAML|XML|HTML|plain text)\u0026rdquo; #This step allows to check whether given last HTTP(s) response body has/doesn\u0026rsquo;t have given format.
First argument format \u0026quot;(JSON|YAML|XML|HTML|plain text)\u0026quot; should be one of available data formats.
Example:
And the response body should have format \u0026quot;JSON\u0026quot; And the response body should not have format \u0026quot;YAML\u0026quot; And the response body should have format \u0026quot;XML\u0026quot; And the response body should have format \u0026quot;plain text\u0026quot; And the response body should have format \u0026quot;HTML\u0026quot; the response body should be valid according to schema \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step allows to check wheter given last HTTP(s) response body is valid according to schema. In tesitng, it is common to do that type of assertions. Schema may be used not only in tests, but also in documentation. That kind of step allows to check not only last response body but also helps keep documentation up to date.
Argument schema \u0026quot;([^\u0026quot;]*)\u0026quot; may be:
full OS path to schema relative OS path to schema. During default setup, command make env creates .env file with env variable GODOG_JSON_SCHEMA_DIR=./assets/test_server/doc/schema. Let\u0026rsquo;s assume, you keep your schemas in your-project-root-dir/docs/schemas/ and placed godog-example-setup in your-project-root-dir/tests/godog/. Then, you have to change environment variable to: GODOG_JSON_SCHEMA_DIR=./../../docs/schemas. From now on, you need to pass relative path as you were in schemas/ directory. full valid URL to schema. Also this argument accepts template values. Examples:
And the response body should be valid according to schema \u0026quot;/usr/local/schemas/user/get_user.json\u0026quot; And the response body should be valid according to schema \u0026quot;user/get_user.json\u0026quot; And the response body should be valid according to schema \u0026quot;{{.CWD}}/assets/test_server/doc/schema/user/user.json\u0026quot; And the response body should be valid according to schema \u0026quot;https://raw.githubusercontent.com/pawelWritesCode/godog-example-setup/main/assets/test_server/doc/schema/user/get_user.json\u0026quot; the response body should be valid according to schema: #This step allows to check wheter given last HTTP(s) response body is valid according to schema.
The only one argument, should be Docstring with schema and may contain template values.
Example:
And the response body should be valid according to schema: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;\$schema\u0026quot;: \u0026quot;https://json-schema.org/draft/2020-12/schema\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;create user\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Valid response from create user endpoint\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot; } \u0026quot;\u0026quot;\u0026quot; `}),e.add({id:11,href:"/docs/steps-definitions/assertions/response-body-nodes/",title:"HTTP response body nodes",description:"HTTP response body nodes.",content:`Overview #Following steps allows to query nodes. Querying nodes is handled by PathFinders utility service. Default setup allows to use following JSON/XML/YAML/HTML path engines:
JSON:
tidwall/gjson oliveagle/jsonpath antchfx/jsonquery YAML:
goccy/go-yaml XML:
antchfx/xmlquery HTML:
antchfx/htmlquery the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; response should (not )?have node \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step checks whether last HTTP(s) response body does have/doesn\u0026rsquo;t have given JSON/YAML/XML/HTML node.
Examples:
And the \u0026quot;JSON\u0026quot; response should have node \u0026quot;data.0.firstName\u0026quot; But the \u0026quot;JSON\u0026quot; response should not have node \u0026quot;\$.data[0].firstName\u0026quot; And the \u0026quot;YAML\u0026quot; response should have node \u0026quot;\$.data[0].firstName\u0026quot; And the \u0026quot;XML\u0026quot; response should have node \u0026quot;//data[0]//firstName\u0026quot; And the \u0026quot;HTML\u0026quot; response should have node \u0026quot;//head//title\u0026quot; Last argument accepts template values.
the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; response should have nodes \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step checks whether last HTTP(s) response body has given JSON/YAML/XML/HTML nodes.
Argument should contain list of expressions-strings pointing at JSON/YAML/XML/HTML nodes, acceptable by APIContext\u0026rsquo;s PathFinders utility service, separated by comma. Last argument may also contain template values.
Examples:
And the \u0026quot;JSON\u0026quot; response should have nodes \u0026quot;\$.data[0].firstName, data.0.lastName, data.1.age\u0026quot; And the \u0026quot;JSON\u0026quot; response should have nodes \u0026quot;id\u0026quot; And the \u0026quot;YAML\u0026quot; response should have nodes \u0026quot;\$.users[{{.USER1_ID}}], \$.users[{{.USER2_ID}}]\u0026quot; And the \u0026quot;XML\u0026quot; response should have nodes \u0026quot;//id\u0026quot; And the \u0026quot;HTML\u0026quot; response should have nodes \u0026quot;//i[1],//i[2]\u0026quot; the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; should be \u0026ldquo;(bool|boolean|float|int|integer|number|scalar|string)\u0026rdquo; of value \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to check last HTTP(s) response JSON/YAML/XML/HTML node against given value.
First argument the \u0026quot;(JSON|YAML|XML|HTML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Argument accepts template values.
Third argument be \u0026quot;(bool|boolean|float|int|integer|number|scalar|string)\u0026quot; of should be one of available data types that you expect.
Last argument value \u0026quot;([^\u0026quot;]*)\u0026quot; should be value of given node. Argument accepts template values.
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;firstName\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot; And the \u0026quot;YAML\u0026quot; node \u0026quot;\$.lastName\u0026quot; should be \u0026quot;scalar\u0026quot; of value \u0026quot;{{.RANDOM_LAST_NAME}}\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;{{.AGE_KEY}}\u0026quot; should be \u0026quot;int\u0026quot; of value \u0026quot;{{.RANDOM_AGE}}\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.age\u0026quot; should be \u0026quot;number\u0026quot; of value \u0026quot;18\u0026quot; And the \u0026quot;XML\u0026quot; node \u0026quot;//age\u0026quot; should be \u0026quot;int\u0026quot; of value \u0026quot;18\u0026quot; And the \u0026quot;HTML\u0026quot; node \u0026quot;//head//title\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;my page title\u0026quot; the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; should be \u0026ldquo;(bool|boolean|float|int|integer|number|scalar|string)\u0026rdquo; and contain one of values \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to check last HTTP(s) response JSON/YAML/XML/HTML node against given set of values.
First argument the \u0026quot;(JSON|YAML|XML|HTML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Argument accepts template values.
Third argument be \u0026quot;(bool|boolean|float|int|integer|number|scalar|string)\u0026quot; of should be one of available data types that you expect.
Last argument \u0026quot;([^\u0026quot;]*)\u0026quot; should be string containing values separated by comma (,).
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.age\u0026quot; should be \u0026quot;number\u0026quot; and contain one of values \u0026quot;18, 19, 20\u0026quot; the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; should (not )?contain sub string \u0026ldquo;([^\u0026rdquo;]) #This step allows to check whether string node value contains/ does not contain provided substring.
First argument the \u0026quot;(JSON|YAML|XML|HTML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Argument accepts template values.
Last argument sub string \u0026quot;([^\u0026quot;]*) should be any substring to check against.
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.lastName\u0026quot; should not contain sub string \u0026quot;smith\u0026quot; But the \u0026quot;JSON\u0026quot; node \u0026quot;\$.lastName\u0026quot; should contain sub string \u0026quot;doe\u0026quot; And the \u0026quot;HTML\u0026quot; node \u0026quot;//head//title\u0026quot; should contain sub string \u0026quot;App\u0026quot; the \u0026ldquo;(JSON|YAML|XML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; should (not )?be slice of length \u0026ldquo;(\\d+)\u0026rdquo; #This step allows to check whether given last HTTP(s) response body JSON/YAML/XML node is/is not slice of given length.
First argument the \u0026quot;(JSON|YAML|XML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Argument accepts template values.
Third argument of length \u0026quot;(\\d+)\u0026quot; should be non-negative integer.
Example:
And the \u0026quot;JSON\u0026quot; node \u0026quot;users\u0026quot; should be slice of length \u0026quot;3\u0026quot; And the \u0026quot;YAML\u0026quot; node \u0026quot;\$.users\u0026quot; should be slice of length \u0026quot;3\u0026quot; And the \u0026quot;XML\u0026quot; node \u0026quot;//users\u0026quot; should be slice of length \u0026quot;3\u0026quot; But the \u0026quot;XML\u0026quot; node \u0026quot;//users\u0026quot; should not be slice of length \u0026quot;3\u0026quot; the \u0026ldquo;(JSON|YAML|XML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; should (not )?be \u0026ldquo;(array|bool|boolean|float|int|integer|map|mapping|nil|null|number|object|sequence|scalar|slice|string)\u0026rdquo; #This step allows to check whether given last HTTP(s) response body JSON/YAML node has given type.
First argument the \u0026quot;(JSON|YAML|XML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Expression accepts template values.
Third, be \u0026quot;(array|bool|boolean|float|int|integer|map|mapping|nil|null|number|object|sequence|scalar|slice|string)\u0026quot; should be one of predefined types.
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;users\u0026quot; should be \u0026quot;slice\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.data\u0026quot; should be \u0026quot;nil\u0026quot; And the \u0026quot;YAML\u0026quot; node \u0026quot;\$.data\u0026quot; should be \u0026quot;nil\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;data.users.{{.USER_ID}}.description\u0026quot; should be \u0026quot;string\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;users\u0026quot; should not be \u0026quot;int\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.data\u0026quot; should not be \u0026quot;null\u0026quot; And the \u0026quot;YAML\u0026quot; node \u0026quot;\$.data\u0026quot; should not be \u0026quot;nil\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;data.users.{{.USER_ID}}.description\u0026quot; should not be \u0026quot;bool\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;data.users.0.description\u0026quot; should not be \u0026quot;map\u0026quot; the \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; should (not )?match regExp \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to check whether given last HTTP(s) response body JSON/YAML/XML/HTML node matches/doesn\u0026rsquo;t match given regExp.
First argument the \u0026quot;(JSON|YAML|XML|HTML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON/XML/YAML/HTML-path engine associated with previously selected data format. Argument accepts template values.
Third argument match regExp \u0026quot;([^\u0026quot;]*)\u0026quot; should be valid regular expression.
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;lastName\u0026quot; should match regExp \u0026quot;doe-.*\u0026quot; And the \u0026quot;YAML\u0026quot; node \u0026quot;\$.lastName\u0026quot; should not match regExp \u0026quot;doe-.*\u0026quot; And the \u0026quot;XML\u0026quot; node \u0026quot;//lastName\u0026quot; should match regExp \u0026quot;doe-.*\u0026quot; And the \u0026quot;HTML\u0026quot; node \u0026quot;//head//title\u0026quot; should match regExp \u0026quot;app-.*\u0026quot; the \u0026ldquo;(JSON)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; should be valid according to schema \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to check whether given JSON node is valid according to provided as reference schema
First argument the \u0026quot;(JSON)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON-path engine.
Argument schema \u0026quot;([^\u0026quot;]*)\u0026quot; may be:
full OS path to schema relative OS path to schema. During default setup, command make env creates .env file with env variable GODOG_JSON_SCHEMA_DIR=./assets/test_server/doc/schema. Let\u0026rsquo;s assume, you keep your schemas in your-project-root-dir/docs/schemas/ and placed godog-example-setup in your-project-root-dir/tests/godog/. Then, you have to change environment variable to: GODOG_JSON_SCHEMA_DIR=./../../docs/schemas. From now on, you need to pass relative path as you were in schemas/ directory. full valid URL to schema. Argument also accepts template values Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;user[0].address\u0026quot; should be valid according to schema \u0026quot;https://www.json-schemas.com/adress.json\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;user[{{.USER_ID}}].address\u0026quot; should be valid according to schema \u0026quot;{{.MY_APP_URL}}/adress.json\u0026quot; the \u0026ldquo;(JSON)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; should be valid according to schema: #This step allows to check whether given JSON node is valid according to provided as docstring schema
First argument the \u0026quot;(JSON)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; should should be expression acceptable by JSON-path engine. Argument accepts template values.
Third argument should be Docstring with schema. Argument accepts template values.
Examples:
And the \u0026quot;JSON\u0026quot; node \u0026quot;\$.data\u0026quot; should be valid according to schema: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;\$schema\u0026quot;: \u0026quot;https://json-schema.org/draft/2020-12/schema\u0026quot;, \u0026quot;title\u0026quot;: \u0026quot;users data\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;users data\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;array\u0026quot;, \u0026quot;items\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;properties\u0026quot;: { \u0026quot;name\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; }, \u0026quot;age\u0026quot;: { \u0026quot;type\u0026quot;: \u0026quot;integer\u0026quot; } } } } \u0026quot;\u0026quot;\u0026quot; `}),e.add({id:12,href:"/docs/steps-definitions/assertions/headers/",title:"HTTP response headers",description:"HTTP response headers.",content:`the response should (not )?have header \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step checks whether last HTTP(s) response has/doesn\u0026rsquo;t have given header. Argument have header \u0026quot;([^\u0026quot;]*)\u0026quot; is case sensitive.
Examples:
And the response should have header \u0026quot;Content-Length\u0026quot; And the response should not have header \u0026quot;Content-Type\u0026quot; the response should have header \u0026ldquo;([^\u0026rdquo;])\u0026quot; of value \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step checks whether last HTTP(s) response has given header of given value.
First argument header \u0026quot;([^\u0026quot;]*)\u0026quot; of should be name of header and is case-sensitive, second argument of value \u0026quot;([^\u0026quot;]*)\u0026quot; should be value of header, it may contain template values.
Examples:
And the response should have header \u0026quot;Content-Type\u0026quot; of value \u0026quot;{{.CONTENT_TYPE_JSON}}; charset=UTF-8\u0026quot; `}),e.add({id:13,href:"/docs/steps-definitions/assertions/status-code/",title:"HTTP response status code",description:"HTTP response status code.",content:`the response status code should (not )?be (\\d+) #This step checks against last HTTP(s) response status code.
Examples:
Then the response status code should be 201 But the response status code should not be 200 `}),e.add({id:14,href:"/docs/prologue/introduction/",title:"Introduction",description:"Project contains skeleton that allows to create various types of tests for HTTP(s) API using godog that implements cucumber/gherkin syntax with help of gdutils lib.",content:"Properly coded solution and tests proving it are equally important if we aim for reliable code, that is maintanable, easy to understand and modify.\nOne of mandatory tasks to achieve it, is to find proper tool, which will be used to write tests.\nGodog is one of possibilities. It is implementation of gherkin syntax in GoLang. Tests following gherkin syntax are easy to read for anyone, because they are like common, well known sentences.\nIf developer finds it useful, first task is to read about cucumber/gherkin syntax and godog documentation to understand basic contepts. Next, framework needs to be bootstraped and developed - for example to test HTTP API. This usually takes time and in the reality, it is continuous - never ending process.\nAnd that is why this project exists. It defines folder structure, bootstrap basic components of framework, gives for free over 40 well documented steps for testing HTTP(s) API over JSON/XML/YAML or HTML. On top of that, framework is developed with debugging in mind, to help anyone write reliable tests. Also repository contain binary with example API server and tests written for it (and for other publicly available APIs).\nExample test that can be written with following project without any need for development:\nFeature: Adding new user Web server binary and it's documentation can be found in assets/test_server/ dir. Server contains following endpoints: - GET /alive - healthcheck - POST /users - creates new user - GET /users - retrieve all users - GET /users/{user_id} - retrieve user by user_id - PUT /users/{user_id} - replace user by user_id - DELETE /users/{user_id} - delete user by user_id - POST /users/{user_id}/avatar - add avatar for user of user_id Background: This section runs before every Scenario. Its main purpose is to generate random user data and save it under provided key in scenario cache. Given I generate a random word having from \u0026quot;5\u0026quot; to \u0026quot;10\u0026quot; of \u0026quot;ASCII\u0026quot; characters and save it as \u0026quot;RANDOM_FIRST_NAME\u0026quot; Given I generate a random word having from \u0026quot;3\u0026quot; to \u0026quot;7\u0026quot; of \u0026quot;UNICODE\u0026quot; characters and save it as \u0026quot;RANDOM_LAST_NAME\u0026quot; Given I generate a random sentence having from \u0026quot;3\u0026quot; to \u0026quot;4\u0026quot; of \u0026quot;english\u0026quot; words and save it as \u0026quot;RANDOM_DESCRIPTION\u0026quot; Given I generate a random \u0026quot;int\u0026quot; in the range from \u0026quot;18\u0026quot; to \u0026quot;20\u0026quot; and save it as \u0026quot;RANDOM_AGE\u0026quot; Given I generate current time and travel \u0026quot;backward\u0026quot; \u0026quot;240h\u0026quot; in time and save it as \u0026quot;MEET_DATE\u0026quot; Given I save \u0026quot;application/json\u0026quot; as \u0026quot;CONTENT_TYPE_JSON\u0026quot; Scenario: Successfully create user v1 As application user I would like to create new account #--------------------------------------------------------------------------------------------------- # We send HTTP(s) request using pre-generated data to create new user. # Accessing saved data from scenario cache is done through template syntax from text/template package. # Docstring may be in YAML or JSON format and should have \u0026quot;body\u0026quot; and \u0026quot;headers\u0026quot; keys. When I send \u0026quot;POST\u0026quot; request to \u0026quot;{{.MY_APP_URL}}/users?format=json\u0026quot; with body and headers: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: { \u0026quot;firstName\u0026quot;: \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;doe-{{.RANDOM_LAST_NAME}}\u0026quot;, \u0026quot;age\u0026quot;: {{.RANDOM_AGE}}, \u0026quot;description\u0026quot;: \u0026quot;{{.RANDOM_DESCRIPTION}}\u0026quot;, \u0026quot;friendSince\u0026quot;: \u0026quot;{{.MEET_DATE.Format `2006-01-02T15:04:05Z`}}\u0026quot; }, \u0026quot;headers\u0026quot;: { \u0026quot;Content-Type\u0026quot;: \u0026quot;{{.CONTENT_TYPE_JSON}}\u0026quot; } } \u0026quot;\u0026quot;\u0026quot; Then the response status code should not be 200 But the response status code should be 201 And the response should not have header \u0026quot;Set-Cookie\u0026quot; But the response should have header \u0026quot;Content-Length\u0026quot; And the response should have header \u0026quot;Content-Type\u0026quot; of value \u0026quot;{{.CONTENT_TYPE_JSON}}; charset=UTF-8\u0026quot; And the response body should not have format \u0026quot;plain text\u0026quot; But the response body should have format \u0026quot;JSON\u0026quot; And time between last request and response should be less than or equal to \u0026quot;2s\u0026quot; # uncommenting next line will print data to console # Given I print last response body # Given I print cache data # This waiting is unnecessary, just added for demonstration And I wait \u0026quot;2ms\u0026quot; #--------------------------------------------------------------------------------------------------- # We validate response body with schema from assets/test_server/doc/schema/user/response/user.json # step argument may be: relative|full OS path, URL or raw schema definition # relativity is obtained through env variable GODOG_JSON_SCHEMA_DIR And the response body should be valid according to schema \u0026quot;user/response/user.json\u0026quot; And the response body should be valid according to schema \u0026quot;{{.CWD}}/assets/test_server/doc/schema/user/response/user.json\u0026quot; And the response body should be valid according to schema \u0026quot;https://raw.githubusercontent.com/pawelWritesCode/godog-http-api/main/assets/test_server/doc/schema/user/response/user.json\u0026quot; And the response body should be valid according to schema: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;title\u0026quot;: \u0026quot;create user\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Valid response from create user endpoint\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot; } \u0026quot;\u0026quot;\u0026quot; # also nodes may be validated against schema And the \u0026quot;JSON\u0026quot; node \u0026quot;firstName\u0026quot; should be valid according to schema: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;title\u0026quot;: \u0026quot;first name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } \u0026quot;\u0026quot;\u0026quot; # querying JSON nodes in any step may be done using three different json-path engines # tidwall/gjson or oliveagle/jsonpath or antchfx/jsonquery And the \u0026quot;JSON\u0026quot; node \u0026quot;firstName\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;$.lastName\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;doe-{{.RANDOM_LAST_NAME}}\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;//lastName\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;doe-{{.RANDOM_LAST_NAME}}\u0026quot; # you can look for substrings And the \u0026quot;JSON\u0026quot; node \u0026quot;$.lastName\u0026quot; should not contain sub string \u0026quot;smith\u0026quot; But the \u0026quot;JSON\u0026quot; node \u0026quot;lastName\u0026quot; should contain sub string \u0026quot;doe\u0026quot; # this step uses regExp acceptable by standard go package \u0026quot;regExp\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;lastName\u0026quot; should not match regExp \u0026quot;smith-.*\u0026quot; But the \u0026quot;JSON\u0026quot; node \u0026quot;//lastName\u0026quot; should match regExp \u0026quot;doe-.*\u0026quot; # assertion may be based on one of JSON data types: array, boolean, null, number, object And the \u0026quot;JSON\u0026quot; node \u0026quot;age\u0026quot; should not be \u0026quot;string\u0026quot; But the \u0026quot;JSON\u0026quot; node \u0026quot;$.age\u0026quot; should be \u0026quot;number\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;$.age\u0026quot; should be \u0026quot;number\u0026quot; and contain one of values \u0026quot;18, 19, 20\u0026quot; # assertion may be based on one of Go-like data types: bool, float, int, map, slice, string But the \u0026quot;JSON\u0026quot; node \u0026quot;$.age\u0026quot; should be \u0026quot;int\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;age\u0026quot; should be \u0026quot;int\u0026quot; of value \u0026quot;{{.RANDOM_AGE}}\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;description\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;{{.RANDOM_DESCRIPTION}}\u0026quot; # date can be formatted according to one of available formats from standard go package \u0026quot;time\u0026quot; And the \u0026quot;JSON\u0026quot; node \u0026quot;friendSince\u0026quot; should be \u0026quot;string\u0026quot; of value \u0026quot;{{.MEET_DATE.Format `2006-01-02T15:04:05Z`}}\u0026quot; "}),e.add({id:15,href:"/docs/steps-definitions/flow-control/wait/",title:"Pause for given period of time.",description:"Pause for given period of time.",content:`I wait \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step allows to stop scenario execution for some time. Sometimes, if you know, that API does not process your request immediately, and you want to wait for short amount of time before sending another HTTP(s) request you can do it with this method.
The only one argument, should be string acceptable by time.ParseDuration.
Example:
Given I wait \u0026quot;3s\u0026quot; Given I wait \u0026quot;20ms\u0026quot; `}),e.add({id:16,href:"/docs/steps-definitions/debugging/print-last-response-body/",title:"Print last response body.",description:"Print last response body.",content:`I print last response body #This step simply prints to console last HTTP(s) response body.
Example:
Given I print last response body `}),e.add({id:17,href:"/docs/steps-definitions/debugging/print-cache-data/",title:"Print scenario cache data.",description:"Print scenario cache data.",content:`I print cache data #This step simply prints current scenario cache data to console.
Example:
Given I print cache data `}),e.add({id:18,href:"/docs/steps-definitions/data-generation/random-boolean/",title:"Random boolean",description:"Generate random boolean value",content:`I generate a random bool value and save it as \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step allows to generate random boolean value and save it in scenario cache.
The only one argument it as \u0026quot;([^\u0026quot;]*)\u0026quot; allows you to pick name under which generated boolean value will be saved in scenario cache.
Example:
Given I generate a random bool value and save it as \u0026quot;IS_WATER_BOILING\u0026quot; `}),e.add({id:19,href:"/docs/steps-definitions/data-generation/random-number-from-the-range/",title:"Random number from the range",description:"Generate random int or float from provided range.",content:`I generate a random \u0026ldquo;(int|float)\u0026rdquo; in the range from \u0026ldquo;([^\u0026rdquo;])\u0026quot; to \u0026ldquo;([^\u0026rdquo;])\u0026quot; and save it as \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step generates random number and save it in scenario cache. To obtain once saved value, use syntax from text/template package.
First argument random \u0026quot;(int|float)\u0026quot; in allows to pick type of number.
Second argument from \u0026quot;([^\u0026quot;]*)\u0026quot; to \u0026quot;([^\u0026quot;]*)\u0026quot; and allows to pick interval from which number will be generated.
Last argument and save it as \u0026quot;([^\u0026quot;]*)\u0026quot;\$ allows you to pick name under which generated number will be saved in scenario cache.
Tip: Later, if you want to use generated float, you can format it using functions from text/template package, for example
Given I generate a random \u0026quot;float\u0026quot; in the range from \u0026quot;34.5\u0026quot; to \u0026quot;39.4\u0026quot; and save it as \u0026quot;RANDOM_TEMPERATURE_C\u0026quot; When I send \u0026quot;POST\u0026quot; request to \u0026quot;{{.MY_APP_URL}}/data\u0026quot; with body and headers: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: { \u0026quot;temperature\u0026quot;: {{printf \`%.2f\` .RANDOM_TEMPERATURE_C}} }, \u0026quot;headers\u0026quot;: { \u0026quot;Content-Type\u0026quot;: \u0026quot;{{.CONTENT_TYPE_JSON}}\u0026quot; } } \u0026quot;\u0026quot;\u0026quot; Examples:
Given I generate a random \u0026quot;int\u0026quot; in the range from \u0026quot;18\u0026quot; to \u0026quot;48\u0026quot; and save it as \u0026quot;RANDOM_AGE\u0026quot; Given I generate a random \u0026quot;float\u0026quot; in the range from \u0026quot;35.5\u0026quot; to \u0026quot;38.3\u0026quot; and save it as \u0026quot;RANDOM_TEMPERATURE_C\u0026quot; `}),e.add({id:20,href:"/docs/steps-definitions/data-generation/random-sentence-from-charset-and-range/",title:"Random sentence from provided charset and range",description:"Generate random sentence from provided charset and range",content:`I generate a random sentence having from \u0026ldquo;(\\d+)\u0026rdquo; to \u0026ldquo;(\\d+)\u0026rdquo; of \u0026ldquo;(ASCII|UNICODE|polish|english|russian|japanese|emoji)\u0026rdquo; words and save it as \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step generates sentence and save it in scenario cache. To obtain once saved value, use syntax from text/template package. This step is something like lorem-ipsum generator.
First two arguments from \u0026quot;(\\d+)\u0026quot; to \u0026quot;(\\d+)\u0026quot; of allows to pick length of sentence - number of words in it.
Argument of \u0026quot;(ASCII|UNICODE|polish|english|russian|japanese|emoji)\u0026quot; words determine charset from which each word will be generated. Last argument save it as \u0026quot;([^\u0026quot;]*)\u0026quot;\$ allows to pick name under which randomly generated sentence will be saved in scenario cache.
ðŸ‘‰ In default setup, each word is defined to have between 3 and 10 characters. You can change it, by passing another values to step's definition method in 'main_test.go' Examples:
Given I generate a random sentence having from \u0026quot;2\u0026quot; to \u0026quot;2\u0026quot; of \u0026quot;english\u0026quot; words and save it as \u0026quot;NAME_AND_SURNAME\u0026quot; Given I generate a random sentence having from \u0026quot;1\u0026quot; to \u0026quot;4\u0026quot; of \u0026quot;polish\u0026quot; words and save it as \u0026quot;RANDOM_DESCRIPTION\u0026quot; `}),e.add({id:21,href:"/docs/steps-definitions/data-generation/random-word-from-charset-and-range/",title:"Random word from provided charset and range",description:"Generate random word from provided charset and range.",content:`I generate a random word having from \u0026ldquo;(\\d+)\u0026rdquo; to \u0026ldquo;(\\d+)\u0026rdquo; of \u0026ldquo;(ASCII|UNICODE|polish|english|russian|japanese|emoji)\u0026rdquo; characters and save it as \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step generates random word and save it in scenario cache.
First two arguments: from \u0026quot;(\\d+)\u0026quot; to \u0026quot;(\\d+)\u0026quot; of allows to set length of the word. For example, from \u0026quot;2\u0026quot; to \u0026quot;4\u0026quot; of will generate word having between 2 and 4 characters. If you want to generate word of fixed length simply pass two times the same value: from \u0026quot;4\u0026quot; to \u0026quot;4\u0026quot; of This will generate word having 4 characters.
Next argument of \u0026quot;(ASCII|UNICODE|polish|english|russian|japanese|emoji)\u0026quot; characters allows to pick charset from which word will be generated. At the moment of writing this guide, there are only few available:
ASCII - basic set of characters like: a, b UNICODE - contains multi byte characters like: a, b, Ä…, âš”, ðŸž polish - characters that exist in polish alphabet english - characters that exist in english alphabet russian - characters that exist in russian alphabet japanese - characters that exist in japanese alphabet emoji - small subset of emojis If you want to add ability to generate word from your custom charset, see IGenerateARandomRunesOfLengthWithCharactersAndSaveItAs method. You have to add another case with your charset. You have to add it also to step definition. For example, lets say you want to add ability to generate word from german characters, then - in method, add
case \u0026quot;german\u0026quot;: generateWordFunc = s.APIContext.IGenerateARandomRunesInTheRangeToAndSaveItAs(\u0026quot;aAÃ¤Ã„...\u0026quot;) and update step definition: of \u0026quot;(ASCII|UNICODE|polish|english|russian|japanese|emoji|german)\u0026quot; characters. Repository charset holds many pre-defined charsets, you can use any if you want and add it to your step definition.
Last argument and save it as \u0026quot;([^\u0026quot;]*)\u0026quot;\$ allows you to pick name under which generated word will be saved in scenario cache.
Examples:
Given I generate a random word having from \u0026quot;5\u0026quot; to \u0026quot;10\u0026quot; of \u0026quot;russian\u0026quot; characters and save it as \u0026quot;RANDOM_FIRST_NAME\u0026quot; Given I generate a random word having from \u0026quot;5\u0026quot; to \u0026quot;15\u0026quot; of \u0026quot;UNICODE\u0026quot; characters and save it as \u0026quot;RANDOM_LAST_NAME\u0026quot; `}),e.add({id:22,href:"/docs/steps-definitions/preserving-data/save-arbitrary-inline-data/",title:"Save arbitrary inline data.",description:"Save arbitrary inline data.",content:`I save \u0026ldquo;([^\u0026rdquo;])\u0026quot; as \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to save arbitrary data from first argument into scenario cache under any key passed as second argument. Argument accepts template values.
Example:
Given I save \u0026quot;application/json\u0026quot; as \u0026quot;CONTENT_TYPE_JSON\u0026quot; Given I save \u0026quot;PaweÅ‚\u0026quot; as \u0026quot;MY_NAME\u0026quot; `}),e.add({id:23,href:"/docs/steps-definitions/preserving-data/save-arbitrary-multiline-data/",title:"Save arbitrary multiline data.",description:"Save arbitrary multiline data.",content:`I save as \u0026ldquo;([^\u0026rdquo;]*)\u0026quot;: #This step allows to save arbitrary multiline data into scenario cache under any key passed as first argument. DocString accepts template values.
Example:
Given I save as \u0026quot;EMPTY_HEADER_AND_BODY\u0026quot;: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: {}, \u0026quot;headers\u0026quot;: {} } \u0026quot;\u0026quot;\u0026quot; `}),e.add({id:24,href:"/docs/steps-definitions/preserving-data/save-data-from-headers/",title:"Save data from headers.",description:"Save data from headers.",content:`I save from the last response header \u0026ldquo;([^\u0026rdquo;])\u0026quot; as \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step allows to save given header value from last response.
First argument header \u0026quot;([^\u0026quot;]*)\u0026quot; as should be upper case-sensitive name of header from last HTTP(s) response.
Last argument as \u0026quot;([^\u0026quot;]*)\u0026quot; allows you to pick name under which picked header value will be saved in scenario cache.
`}),e.add({id:25,href:"/docs/steps-definitions/preserving-data/save-data-from-response-body/",title:"Save data from last response body.",description:"Save data from last response body.",content:`I save from the last response \u0026ldquo;(JSON|YAML|XML|HTML)\u0026rdquo; node \u0026ldquo;([^\u0026rdquo;])\u0026quot; as \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This steps allows to obtain JSON/YAML/XML/HTML node from last HTTP(s) response and save it in scenario chace under given key.
First argument the \u0026quot;(JSON|YAML|XML|HTML)\u0026quot; node should be expected data format of response body.
Second argument node \u0026quot;([^\u0026quot;]*)\u0026quot; use APIContext\u0026rsquo;s PathFinders utility service. Default setup allows to use syntax from two different libraries (for JSON) and one for YAML and XML, which are described above. Argument accepts template values.
Last argument as \u0026quot;([^\u0026quot;]*)\u0026quot; allows you to pick name under which picked node value will be saved in scenario cache.
Example:
And I save from the last response \u0026quot;JSON\u0026quot; node \u0026quot;id\u0026quot; as \u0026quot;USER_ID\u0026quot; And I save from the last response \u0026quot;YAML\u0026quot; node \u0026quot;\$.id\u0026quot; as \u0026quot;USER_ID\u0026quot; And I save from the last response \u0026quot;XML\u0026quot; node \u0026quot;//id\u0026quot; as \u0026quot;USER_ID\u0026quot; And I save from the last response \u0026quot;JSON\u0026quot; node \u0026quot;@this.size\u0026quot; as \u0026quot;TOWN_SIZE\u0026quot; And I save from the last response \u0026quot;JSON\u0026quot; node \u0026quot;@this.{{.SIZE_KEY}}\u0026quot; as \u0026quot;TOWN_SIZE\u0026quot; `}),e.add({id:26,href:"/docs/steps-definitions/http-requests/sending-request-v2/",title:"Sending request using multiple steps",description:"Sending request using multiple steps.",content:`I prepare new \u0026ldquo;(GET|POST|PUT|PATCH|DELETE|HEAD)\u0026rdquo; request to \u0026ldquo;([^\u0026rdquo;])\u0026quot; and save it as \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step prepares new HTTP(s) request.
First argument send \u0026quot;(GET|POST|PUT|PATCH|DELETE|HEAD)\u0026quot; request is one of well known HTTP request methods.
Second argument to \u0026quot;([^\u0026quot;]*)\u0026quot; with should be full valid URL. Argument accepts template values. For example to \u0026quot;{{.MY_APP_URL}}/api/user\u0026quot; with or to \u0026quot;https://www.example.com\u0026quot; with. Of course {{.MY_APP_URL}} should be previously saved in scenario cache.
Last argument and save it as \u0026quot;([^\u0026quot;]*)\u0026quot;\$ allows you to pick name under which prepared request will be saved in scenario cache.
Example:
Given I prepare new \u0026quot;POST\u0026quot; request to \u0026quot;{{.MY_APP_URL}}/users\u0026quot; and save it as \u0026quot;CREATE_USER\u0026quot; I set following headers for prepared request \u0026ldquo;([^\u0026rdquo;]*)\u0026quot;: #This step allows to set headers for previously prepared request
First argument request \u0026quot;([^\u0026quot;]*)\u0026quot; should be name under which request is saved in scenario cache. For example request \u0026quot;CREATE_USER\u0026quot;.
Second argument should be Docstring in form of YAML or JSON with headers. It accepts template values.
Example:
Given I set following headers for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; --- Content-Type: application/json \u0026quot;\u0026quot;\u0026quot; or
Given I set following headers for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;Content-Type\u0026quot;: \u0026quot;application/json\u0026quot; } \u0026quot;\u0026quot;\u0026quot; I set following form for prepared request \u0026ldquo;([^\u0026rdquo;]*)\u0026quot;: #This step allows to set form for prepared request.
First argument request \u0026quot;([^\u0026quot;]*)\u0026quot; should be name under which request is saved in scenario cache. For example request \u0026quot;CREATE_USER\u0026quot;.
Second argument should be Docstring in YAML or JSON with form fields and their corresponding values. To attach any file, use following syntax: file://path/to/file as key value.
Its worth to mention that method automatically sets Content-Type: multipart/form-data header with proper boundary. If you want to change Content-Type header to application/x-www-form-urlencoded, afterwards use step for setting headers to overwrite it.
Example:
Given I set following form for prepared request \u0026quot;AVATAR_REQUEST\u0026quot;: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;name\u0026quot;: \u0026quot;{{.RANDOM_AVATAR_NAME}}.gif\u0026quot;, \u0026quot;avatar\u0026quot;: \u0026quot;file://{{.CWD}}/assets/gifs/hand-pointing-left.gif\u0026quot; } \u0026quot;\u0026quot;\u0026quot; I set following cookies for prepared request \u0026ldquo;([^\u0026rdquo;]*)\u0026quot;: #This step allows to set cookies for prepared request.
First argument request \u0026quot;([^\u0026quot;]*)\u0026quot; should be name under which request is saved in scenario cache. For example request \u0026quot;CREATE_USER\u0026quot;.
Second argument should be Docstring in YAML or JSON with list of elements having keys name and value.
Examples:
Given I set following cookies for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; [ { \u0026quot;name\u0026quot;: \u0026quot;csrf_token\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;this_cookie_is_unnecessary_just_added_for_demonstration\u0026quot; } ] \u0026quot;\u0026quot;\u0026quot; I set following body for prepared request \u0026ldquo;([^\u0026rdquo;]*)\u0026quot;: #This step allows to set request body in any format.
First argument request \u0026quot;([^\u0026quot;]*)\u0026quot; should be name under which request is saved in scenario cache. For example request \u0026quot;CREATE_USER\u0026quot;.
Second argument should be Docstring in any form. It accepts template values.
Examples:
Given I set following body for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;firstName\u0026quot;: \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;{{.RANDOM_LAST_NAME}}\u0026quot;, \u0026quot;age\u0026quot;: {{.RANDOM_AGE}} } \u0026quot;\u0026quot;\u0026quot; Given I set following body for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; plain text \u0026quot;\u0026quot;\u0026quot; Given I set following body for prepared request \u0026quot;CREATE_USER\u0026quot;: \u0026quot;\u0026quot;\u0026quot; --- firstName: {{.RANDOM_FIRST_NAME}} age: {{.RANDOM_AGE}} \u0026quot;\u0026quot;\u0026quot; I send request \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step sends previously prepared request. May be used many times for one request.
Example:
When I send request \u0026quot;CREATE_USER\u0026quot; `}),e.add({id:27,href:"/docs/steps-definitions/http-requests/sending-request-v1/",title:"Sending request using single step.",description:"Sending request using single step.",content:`I send \u0026ldquo;(GET|POST|PUT|PATCH|DELETE|HEAD)\u0026rdquo; request to \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; with body and headers: #This steps allows to send HTTP(s) request.
First argument send \u0026quot;(GET|POST|PUT|PATCH|DELETE|HEAD)\u0026quot; request is one of well known HTTP request methods.
Second argument to \u0026quot;([^\u0026quot;]*)\u0026quot; with should be full valid URL. Argument accepts template values. For example to \u0026quot;{{.MY_APP_URL}}/api/user\u0026quot; with or to \u0026quot;https://www.example.com\u0026quot; with. Of course {{.MY_APP_URL}} should be previously saved in scenario cache.
Last argument, should be Docstring in form of YAML or JSON with keys: body, headers. For example
\u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: { \u0026quot;firstName\u0026quot;: \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;{{.RANDOM_LAST_NAME}}\u0026quot;, \u0026quot;age\u0026quot;: {{.RANDOM_AGE}} }, \u0026quot;headers\u0026quot;: { \u0026quot;Content-Type\u0026quot;: \u0026quot;application/json\u0026quot; } } \u0026quot;\u0026quot;\u0026quot; or YAML equivalent
\u0026quot;\u0026quot;\u0026quot; --- body: firstName: \u0026quot;{{.RANDOM_FIRST_NAME}}\u0026quot; lastName: \u0026quot;{{.RANDOM_LAST_NAME}}\u0026quot; age: {{.RANDOM_AGE}} headers: Content-Type: application/json \u0026quot;\u0026quot;\u0026quot; Example:
When I send \u0026quot;DELETE\u0026quot; request to \u0026quot;{{.MY_APP_URL}}/users/{{.USER_ID}}\u0026quot; with body and headers: \u0026quot;\u0026quot;\u0026quot; { \u0026quot;body\u0026quot;: {}, \u0026quot;headers\u0026quot;: { \u0026quot;Content-Type\u0026quot;: \u0026quot;application/json\u0026quot; } } \u0026quot;\u0026quot;\u0026quot; `}),e.add({id:28,href:"/docs/steps-definitions/flow-control/stop/",title:"Stop scenario execution.",description:"Stop scenario execution.",content:`I stop scenario execution #This step stops scenario execution
Example:
And I stop scenario execution `}),e.add({id:29,href:"/docs/steps-definitions/data-generation/time-object/",title:"Time object",description:"Generate time object.",content:"I generate current time and travel \u0026ldquo;(backward|forward)\u0026rdquo; \u0026ldquo;([^\u0026rdquo;])\u0026quot; in time and save it as \u0026ldquo;([^\u0026rdquo;])\u0026quot; #\rThis step allows to generate time object, moved backward/forward in time and save it to scenario cache.\nFirst argument and travel \u0026quot;(backward|forward)\u0026quot; tells whether user want to move forward or backward in time. If you want to simply get current time object just pass any of both.\nSecond argument \u0026quot;([^\u0026quot;]*)\u0026quot; in time should be string acceptable by time.ParseDuration. It tells how much time should we travel in time.\nLast argument and save it as \u0026quot;([^\u0026quot;]*)\u0026quot;$ allows you to pick name under which generated time object will be saved in scenario cache.\nFuther use of this saved time object should be done through templates. You most probably want to format it according to your needs. Syntax is: {{.CACHE-KEY-OF-TIME-OBJECT.Format \u0026quot;time-format\u0026quot;}}. See avaialble time-formats. Examples:\nGiven I generate current time and travel \u0026quot;forward\u0026quot; \u0026quot;0s\u0026quot; in time and save it as \u0026quot;CURRENT_TIME\u0026quot; Given I generate current time and travel \u0026quot;forward\u0026quot; \u0026quot;31d\u0026quot; in time and save it as \u0026quot;NEXT_MONTH\u0026quot; Given I generate current time and travel \u0026quot;backward\u0026quot; \u0026quot;5m\u0026quot; in time and save it as \u0026quot;5_MINUTES_AGO\u0026quot; Examples of usage in Docstring (assuming, that time object is saved under TIME key in scenario cache):\n`{{.TIME}}` `{{.TIME.Format \u0026quot;2006-01-02T15:04:05Z07:00\u0026quot;}}` `{{.TIME.Format \u0026quot;2006-01-02\u0026quot;}}` "}),e.add({id:30,href:"/docs/usage/go-cli/",title:"CLI: go",description:"How to run tests using go CLI.",content:`Description #Go CLI is a tool shipped with GoLang installation. It contains various commands for working with your Go projects.
ðŸ‘‰ Go CLI is recommended method for running tests. ðŸ‘‰ This section assumes you have already run 'make all' or 'make download-dependencies' command from root project directory. Usages #To run all tests:
go test To run all tests in random order marked with tag wip asynchronously using 2 CPUs:
go test -v --godog.random --godog.tags=wip --godog.concurrency=2 For more info see godog\u0026rsquo;s README TestMain section.
`}),e.add({id:31,href:"/docs/prologue/quick-start/",title:"Quick Start",description:"How to get copy of project and run tests.",content:`Prerequisites #Git GoLang 1.19+ Docker with built-in compose command (optional) Makefile support (optional) Setup #Note: Some users may require to run commands with sudo
git clone https://github.com/pawelWritesCode/godog-http-api.git \u0026amp;\u0026amp; cd godog-http-api Next run all command:
make all Afterwards you can run tests using 3 distinct ways
Local OS #make tests-using-host Docker #make tests-using-docker Docker compose #make tests-using-compose For more usage examples examine Usage section.
From now on, you can write your own tests (files with *.feature extension) using provided pre-defined steps.
ðŸ‘‰ Note that at this moment project contains unnecessary files and directories which exists mainly for training purposes. `}),e.add({id:32,href:"/docs/usage/debugging/",title:"Debugging",description:"How to debug scenarios.",content:`Writing tests especially in the beginning is not easy. That is why framework is developed with debugging in mind.
Service responsible for debugging is Debugger.
In code, inside methods, it usually looks like this:
if s.Debugger.IsOn() { command, _ := http2curl.GetCurlCommand(req) s.Debugger.Print(command.String()) } Whenever you write your own custom methods, add similar code to provide additional info while working with turned on debugging mode.
If you want to debug scenario, first thing you want to do is to selectively run feature. See CLI: godog. :
godog run features/path/to/your/feature.feature If you have to run only one scenario, the best way is to add tag over it:
@wip Scenario: Successfully send avatar and then run it with following command:
godog run --tags=wip or
go test -v --godog.tags=wip Debugging mode may be turned on in two ways:
globally, by setting environment variable: GODOG_DEBUG=true in .env file, in scenario, using I start debug mode and I stop debug mode steps. First option turns on debugger for every scenario. It is not good idea to run whole regression (all tests) when debug mode is on, because output will be large and hard to read. Run test by OS path or tag as described above.
Second option allows to focus selectively on steps. For example
Given I start debug mode When I send request \u0026quot;CREATE_USER\u0026quot; Given I stop debug mode Will only turn on debugger for I send request \u0026quot;CREATE_USER\u0026quot; step. In this case, output will be similar to:
Given I start debug mode # scenario.go:295 -\u0026gt; *Scenario debug: curl -X 'POST' -d ' { \u0026quot;firstName\u0026quot;: \u0026quot;CÅºÄ„da\u0026quot;, \u0026quot;lastName\u0026quot;: \u0026quot;doe-á«ï²€á†«ð‘™â‚°\u0026quot;, \u0026quot;age\u0026quot;: 35, \u0026quot;description\u0026quot;: \u0026quot;hTIDcADY HWOiH olnXJiZT hFfusyFx\u0026quot;, \u0026quot;friendSince\u0026quot;: \u0026quot;2022-03-02T08:54:43Z\u0026quot; }' -H 'Content-Type: application/json' -H 'Cookie: csrf_token=this_cookie_is_unnecessary_just_added_for_demonstration' 'http://localhost:1234/users' debug: last response body: {\u0026quot;id\u0026quot;:2,\u0026quot;firstName\u0026quot;:\u0026quot;CÅºÄ„da\u0026quot;,\u0026quot;lastName\u0026quot;:\u0026quot;doe-á«ï²€á†«ð‘™â‚°\u0026quot;,\u0026quot;age\u0026quot;:35,\u0026quot;description\u0026quot;:\u0026quot;hTIDcADY HWOiH olnXJiZT hFfusyFx\u0026quot;,\u0026quot;friendSince\u0026quot;:\u0026quot;2022-03-02T08:54:43Z\u0026quot;} When I send request \u0026quot;CREATE_USER\u0026quot; # scenario.go:146 -\u0026gt; /defs.Scenario.ISendRequest-fm Given I stop debug mode As you see, debugging mode, for sending HTTP(s) request step shows CURL that is sent to server and response body from this request. You can use this CURL to examine, whether your request was composed properly or play on-site with it. Additionally, you see server response immediately for this request.
It\u0026rsquo;s worth to mention, that you may run whole test regression (all tests) and output will be normal, but with additional lines from debugger just for that step.
Another thing, you may want to use is step:
Given I print last response body It simply prints last response body to console.
Or you may want to see what\u0026rsquo;s in scenario cache. Do it with following:
Given I print cache data Lastly, if your scenario is too long, you may want to stop it half way. To do this, use step:
Given I stop scenario execution `}),e.add({id:33,href:"/docs/prologue/overview/",title:"Overview",description:"Directory structure explained.",content:`Unmodified cloned project #. â”œâ”€â”€ assets â”‚Â â”œâ”€â”€ gifs â”‚Â â”œâ”€â”€ svg â”‚Â â””â”€â”€ test_server â”œâ”€â”€ compose.yaml â”œâ”€â”€ defs â”‚Â â””â”€â”€ scenario.go â”œâ”€â”€ Dockerfile â”œâ”€â”€ features â”‚Â â”œâ”€â”€ 7timer â”‚Â â”œâ”€â”€ helium â”‚Â â”œâ”€â”€ httpbin â”‚Â â””â”€â”€ test_server â”œâ”€â”€ go.mod â”œâ”€â”€ go.sum â”œâ”€â”€ LICENSE â”œâ”€â”€ main_test.go â”œâ”€â”€ Makefile â””â”€â”€ README.MD ðŸ‘‰ Above structure contains directories and files that you won't need in long run. However, It's convenient to play around before stripping them. Make clean #Predefined command make clean strips project from unnecessary files and directories (also hidden ones). You can run it when you are done with experimenting, and you understand basic concepts of project.
â”œâ”€â”€ compose.yaml â”œâ”€â”€ defs â”‚Â â””â”€â”€ scenario.go â”œâ”€â”€ Dockerfile â”œâ”€â”€ go.mod â”œâ”€â”€ go.sum â”œâ”€â”€ LICENSE â”œâ”€â”€ main_test.go â”œâ”€â”€ Makefile â””â”€â”€ README.MD assets/ #ðŸ‘‰ Subject to remove by 'make clean' This directory contains gifs/ and svgs/ subdirectories with images used by README.MD.
test_server/ directory contains example web server binary that allows to make CRUD operations for User entity to play around and its documentation in OpenAPI format. See pawelWritesCode/user-crud repository, Docker Hub image and predefined tests for it.
defs/ #This directory contains definitions used behind defined steps (golang code). Add your custom definitions code here.
features/ #ðŸ‘‰ Subject to remove by 'make clean' This directory contains tests. Those are files with *.feature extension grouped in logical subdirectories.
compose.yaml #This file contains definition of multi container application. It exists only for demonstration purposes to show how tests can be defined in it.
Dockerfile #This file contains containerization definition for project.
go.mod \u0026amp; go.sum #Those files lists used GoLang packages.
main_test.go #Contains definition of steps and framework setup.
Makefile #Source of useful commands to work with project.
LICENCE #Pure informational file with license description.
`}),e.add({id:34,href:"/docs/utility-services/cache/",title:"Cache",description:"Service responsible for storing data across scenario.",content:`Cache of type cache.Cache #This service preserve data between steps in one scenario.
// Cache is entity that has ability to store/retrieve arbitrary values. type Cache interface { // Save preserve provided value under given key. Save(key string, value interface{}) // GetSaved retrieve value from given key. GetSaved(key string) (interface{}, error) // Reset turns cache into init state - clears all entries. Reset() // All returns all cache entries. All() map[string]interface{} } To replace it with your own implementation use following setter.
func (apiCtx *APIContext) SetCache(c cache.Cache) Some examples of custom cache may be:
one which stores data in database (Redis, mongoDB, any SQL-like) one which logs every saved value for debugging purposes `}),e.add({id:35,href:"/docs/utility-services/debugger/",title:"Debugger",description:"Service responsible for debugging.",content:`Debugger of type debugger.Debugger #This service is useful for debugging. It is self-aware service with mutate state.
// Debugger represents debugger. type Debugger interface { // Print prints provided info. Print(info string) // IsOn tells whether debugging mode is activated. IsOn() bool // TurnOn turns on debugging mode. TurnOn() // TurnOff turns off debugging mode. TurnOff() // Reset resets debugging mode to init state. Reset(isOn bool) } To replace it with your own implementation use following setter.
// SetDebugger sets new debugger for State. func (apiCtx *APIContext) SetDebugger(d debugger.Debugger) Some examples of custom debugger may be:
one which do not print to console, but to file one which output is colored one which output may be prefixed or formatted differently `}),e.add({id:36,href:"/docs/utility-services/formatters/",title:"Formatters",description:"Services responsible for serialization/deserialization data of given formats.",content:`Formatters of struct type Formatters #Those service are responsible for serialization and deserialization data.
// Formatters is container for entities that know how to serialize and deserialize data. type Formatters struct { // JSON is entity that has ability to serialize and deserialize JSON bytes. JSON formatter.Formatter // YAML is entity that has ability to serialize and deserialize YAML bytes. YAML formatter.Formatter // XML is entity that has ability to serialize and deserialize XML bytes. XML formatter.Formatter } Each formatter has to implement
// Formatter describes ability to serialize and deserialize data type Formatter interface { // Deserialize deserializes data on v Deserialize(data []byte, v interface{}) error // Serialize serializes v Serialize(v interface{}) ([]byte, error) } To replace them with your own implementation use following setters:
// SetJSONFormatter sets new JSON formatter for APIContext. func (apiCtx *APIContext) SetJSONFormatter(jf formatter.Formatter) // SetYAMLFormatter sets new YAML formatter for APIContext. func (apiCtx *APIContext) SetYAMLFormatter(yd formatter.Formatter) // SetXMLFormatter sets new XML formatter for APIContext. func (apiCtx *APIContext) SetXMLFormatter(xf formatter.Formatter) JSON has ability to serialize/deserialize data in JSON format, YAML has ability to serialize/deserialize data in YAML format, XML has ability to serialize/deserialize data in XML format
Some examples of custom formatters may be:
one that format with indentation `}),e.add({id:37,href:"/docs/utility-services/path-finders/",title:"PathFinders",description:"Services responsible for querying nodes of data from different formats.",content:`PathFinders of struct type PathFinders #Those services allows to query response body tree to obtain nodes.
// PathFinders is container for different data types pathfinders. type PathFinders struct { // JSON is entity that has ability to obtain data from bytes in JSON format. JSON pathfinder.PathFinder // YAML is entity that has ability to obtain data from bytes in YAML format. YAML pathfinder.PathFinder // XML is entity that has ability to obtain data from bytes in XML format. XML pathfinder.PathFinder // HTML is entity that has ability to obtain data from bytes in HTML format. HTML pathfinder.PathFinder } To replace them with your own implementation use following setters:
// SetJSONPathFinder sets new JSON pathfinder for APIContext. func (apiCtx *APIContext) SetJSONPathFinder(r pathfinder.PathFinder) // SetYAMLPathFinder sets new YAML pathfinder for APIContext. func (apiCtx *APIContext) SetYAMLPathFinder(r pathfinder.PathFinder) // SetXMLPathFinder sets new XML pathfinder for APIContext. func (apiCtx *APIContext) SetXMLPathFinder(r pathfinder.PathFinder) // SetHTMLPathFinder sets new HTML pathfinder for APIContext. func (apiCtx *APIContext) SetHTMLPathFinder(r pathfinder.PathFinder) JSON allows to query JSON nodes, YAML allows to query YAML nodes, XML allows to query XML nodes, HTML allows to query HTML nodes.
Some examples of custom path finders may be:
one that uses different syntax one that allows to work with many different json-path engines at once. (self aware) `}),e.add({id:38,href:"/docs/utility-services/request-doer/",title:"RequestDoer",description:"Service responsible for sending HTTP requests.",content:`RequestDoer of type httpctx.RequestDoer #This service is responsible for sending HTTP requests.
// RequestDoer describes ability to make HTTP(s) requests. type RequestDoer interface { Do(req *http.Request) (*http.Response, error) } To replace it with your own implementation use following setter:
func (apiCtx *APIContext) SetRequestDoer(r httpctx.RequestDoer) Some examples of custom RequestDoer may be:
one with custom timeout one with implemented tracing one with custom http.Transport field `}),e.add({id:39,href:"/docs/utility-services/schema-validators/",title:"SchemaValidators",description:"Services responsible for validating response body against JSON schema.",content:`SchemaValidators of struct type SchemaValidators #Schema validators are responsible for validating payload against json-schema
// SchemaValidators is container for JSON schema validators. type SchemaValidators struct { // StringValidator represents entity that has ability to validate document against string of containing schema. StringValidator validator.SchemaValidator // ReferenceValidator represents entity that has ability to validate document against string with reference // to schema, which may be URL or relative/full OS path for example. ReferenceValidator validator.SchemaValidator } To replace them with your own implementation use following setters:
// SetSchemaStringValidator sets new schema StringValidator for APIContext. func (apiCtx *APIContext) SetSchemaStringValidator(j validator.SchemaValidator) // SetSchemaReferenceValidator sets new schema ReferenceValidator for APIContext. func (apiCtx *APIContext) SetSchemaReferenceValidator(j validator.SchemaValidator) Each validator has type
// SchemaValidator describes entity that can validate document against some kind of schema. type SchemaValidator interface { // Validate validates document against some kind of schema located in schemaPath. Validate(document, schemaPath string) error } StringValidator validates document against provided schema string, ReferenceValidator validates document against provided schema as reference (path/url)
Some examples of custom schema validators may be:
one which validates JSON schema of different specification than default one one which has ability to accept different type of reference to JSON-schema one which has ability to validate schema in YAML format `}),e.add({id:40,href:"/docs/utility-services/template-engine/",title:"TemplateEngine",description:"Service responsible for templates.",content:`TemplateEngine of type template.Engine #This service is responsible for string templating. It allows to inject previously cached/generated data into step\u0026rsquo;s arguments.
// Engine is entity that has ability to work with templates. type Engine interface { // Replace replaces template values using provided storage. Replace(templateValue string, storage map[string]interface{}) (string, error) } To replace it with your own implementation use following setter:
func (apiCtx *APIContext) SetTemplateEngine(t template.Engine) Some examples of custom template engine may be:
one which uses different syntax for injecting variables one which logs somewhere injected values `}),e.add({id:41,href:"/docs/utility-services/type-mappers/",title:"TypeMappers",description:"Services responsible for mapping internal data structures onto different formats data types.",content:`TypeMappers of struct type TypeMappers #Those services are responsible for mapping internal data structures onto different formats data types.
// TypeMappers is container for different data format mappers type TypeMappers struct { // JSON is entity that has ability to map underlying data type into JSON data type JSON types.Mapper // YAML is entity that has ability to map underlying data type into YAML data type YAML types.Mapper // GO is entity that has ability to map underlying data type into GO-like data type GO types.Mapper } Each mapper has to implement following interface:
// Mapper is entity that has ability to map data's type into corresponding DataType of given format. type Mapper interface { // Map maps data type. Map(data any) DataType } To replace them with your own implementation use following setters:
// SetJSONTypeMapper sets new type mapper for JSON. func (apiCtx *APIContext) SetJSONTypeMapper(c types.Mapper) { apiCtx.TypeMappers.JSON = c } // SetYAMLTypeMapper sets new type mapper for YAML. func (apiCtx *APIContext) SetYAMLTypeMapper(c types.Mapper) { apiCtx.TypeMappers.YAML = c } // SetGoTypeMapper sets new type mapper for Go. func (apiCtx *APIContext) SetGoTypeMapper(c types.Mapper) { apiCtx.TypeMappers.GO = c } `}),e.add({id:42,href:"/docs/prologue/next-steps/",title:"Next steps",description:"Got working copy what's next?",content:`Until now, you should have at least basic understanding how to get your own copy of project and how to run pre-defined tests shipped with it.
Now, you should move to Usage section to understand how tests can be run in different ways. Debugging is also explained there.
Next, see Steps definitions to learn how to create your own custom steps if needed and read pre-defined steps documentation.
Lastly, see Utility services. Treat it as appendix to mentioned above section. Utility services will help you create your own custom steps with compatibility to already developed framework.
`}),e.add({id:43,href:"/docs/steps-definitions/assertions/",title:"Assertions",description:"",content:""}),e.add({id:44,href:"/docs/steps-definitions/debugging/",title:"Debugging",description:"",content:""}),e.add({id:45,href:"/docs/steps-definitions/preserving-data/",title:"Preserving data",description:"",content:""}),e.add({id:46,href:"/docs/utility-services/",title:"Utility services",description:"",content:""}),e.add({id:47,href:"/docs/",title:"Docs",description:"Docs Doks.",content:""}),e.add({id:48,href:"/docs/steps-definitions/assertions/cookies/",title:"",description:`a\u0026mdash; title: \u0026ldquo;HTTP response Cookies\u0026rdquo; description: \u0026ldquo;HTTP response Cookies.\u0026rdquo; lead: \u0026ldquo;HTTP response Cookies.\u0026rdquo; date: 2023-03-27T08:48:57+00:00 lastmod: 2023-03-27T08:48:57+00:00 draft: false weight: 100 toc: true #the response should (not )?have cookie \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step checks whether last HTTP(s) response has/doesn\u0026rsquo;t have given cookie.
The only one argument have cookie \u0026quot;([^\u0026quot;]*)\u0026quot; should be name of cookie.
Examples:
And the response should have cookie \u0026quot;session_id\u0026quot; And the response should not have cookie \u0026quot;csrf_token\u0026quot; the response should have cookie \u0026ldquo;([^\u0026rdquo;])\u0026quot; of value \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step checks whether last HTTP(s) response has given cookie of given value.`,content:`a\u0026mdash; title: \u0026ldquo;HTTP response Cookies\u0026rdquo; description: \u0026ldquo;HTTP response Cookies.\u0026rdquo; lead: \u0026ldquo;HTTP response Cookies.\u0026rdquo; date: 2023-03-27T08:48:57+00:00 lastmod: 2023-03-27T08:48:57+00:00 draft: false weight: 100 toc: true #the response should (not )?have cookie \u0026ldquo;([^\u0026rdquo;]*)\u0026quot; #This step checks whether last HTTP(s) response has/doesn\u0026rsquo;t have given cookie.
The only one argument have cookie \u0026quot;([^\u0026quot;]*)\u0026quot; should be name of cookie.
Examples:
And the response should have cookie \u0026quot;session_id\u0026quot; And the response should not have cookie \u0026quot;csrf_token\u0026quot; the response should have cookie \u0026ldquo;([^\u0026rdquo;])\u0026quot; of value \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step checks whether last HTTP(s) response has given cookie of given value.
First argument cookie \u0026quot;([^\u0026quot;]*)\u0026quot; of should be cookie name.
Second argument value \u0026quot;([^\u0026quot;]*)\u0026quot; should be cookie value. This argument accepts template values.
Examples:
And the response should have cookie \u0026quot;mobile_format\u0026quot; of value \u0026quot;false\u0026quot; And the response should have cookie \u0026quot;user_name\u0026quot; of value \u0026quot;{{.RANDOM_USER_FIRST_NAME}}_{{.RANDOM_USER_LAST_NAME}}\u0026quot; the response cookie \u0026ldquo;([^\u0026rdquo;])\u0026quot; should (not )?match regExp \u0026ldquo;([^\u0026rdquo;])\u0026quot; #This step checks whether last HTTP(s) response has given cookie and compares it to provided regExp.
First argument cookie \u0026quot;([^\u0026quot;]*)\u0026quot; of should be cookie name.
Second argument regExp \u0026quot;([^\u0026quot;]*)\u0026quot; should be valid regular expression acceptable by standard go library.
Examples:
And the response cookie \u0026quot;user_name\u0026quot; should match regExp \u0026quot;john.*\u0026quot; `}),search.addEventListener("input",t,!0);function t(){const s=5;var n=this.value,o=e.search(n,{limit:s,enrich:!0});const t=new Map;for(const e of o.flatMap(e=>e.result)){if(t.has(e.doc.href))continue;t.set(e.doc.href,e.doc)}if(suggestions.innerHTML="",suggestions.classList.remove("d-none"),t.size===0&&n){const e=document.createElement("div");e.innerHTML=`No results for "<strong>${n}</strong>"`,e.classList.add("suggestion__no-results"),suggestions.appendChild(e);return}for(const[r,a]of t){const n=document.createElement("div");suggestions.appendChild(n);const e=document.createElement("a");e.href=r,n.appendChild(e);const o=document.createElement("span");o.textContent=a.title,o.classList.add("suggestion__title"),e.appendChild(o);const i=document.createElement("span");if(i.textContent=a.description,i.classList.add("suggestion__description"),e.appendChild(i),suggestions.appendChild(n),suggestions.childElementCount==s)break}}})()